# Load SQL Architecture

This document describes how elevata transforms metadata into executable SQL for load operations. It reflects the architecture as of the current 0.5.x generation, with SQL generation unified across dialects via the Logical Plan and Expression AST.  

> **Note:** Until v1.0, elevata focuses primarily on generating SELECT-based load SQL. MERGE, DELETE-detection, and advanced write-paths are planned but not yet implemented.

---

# 1. Overview

The load SQL pipeline turns metadata into **complete SQL statements** suitable for execution on various analytical backends.  

High‑level flow:

```
Metadata → Logical Plan → Expression AST → Dialect Rendering → SQL Load Statement
```

The system is designed so that:  
- Metadata stays backend‑agnostic  
- Logical Plans describe *what* is needed, not *how* it is written  
- Dialects control syntactic differences  
- Execution engines (DuckDB, Postgres, MSSQL, ...) remain fully decoupled

---

# 2. Logical Plans for Load Operations

Elevata represents load operations using SQL primitives:  

- `LogicalSelect` – core building block  
- `LogicalUnion` – multi-source resolution  
- `SubquerySource` – ranking, filtering, pre-aggregation  
- (future) `LogicalMerge` – merge/update semantics  
- (future) `LogicalDeleteDetect` – delete handling  

The Logical Plan is intentionally **dialect-neutral**.

---

# 3. Expression AST in Load SQL

During load generation, every column expression is represented as an AST node.  

Supported nodes include:  
- `ColumnRef`  
- `Literal`  
- `ExprRef`  
- `ConcatExpr`  
- `ConcatWsExpr`  
- `CoalesceExpr`  
- `WindowFunctionExpr`  
- `Hash256Expr`  

The AST guarantees that:  
- hashing is consistent across dialects  
- CONCAT/COALESCE behave uniformly  
- window functions are structured, not string‑built  
- SQL remains predictable and comparable

---

# 4. Dialect Rendering

After the Logical Plan is constructed, the load generator asks the selected dialect to turn AST + plan into SQL.

```
sql = dialect.render_select(plan)
```

Each dialect implements:  
- identifier quoting (Postgres → "col", MSSQL → "col", DuckDB → "col")  
- literal rendering (strings, numbers, nulls)  
- hashing functions (SHA‑256 across all dialects)  
- CONCAT / CONCAT_WS  
- COALESCE  
- window functions (ROW_NUMBER)  
- subqueries and unions  

This ensures consistent behavior while using native SQL syntax per backend.

---

# 5. Load Runner

The **Load Runner CLI** (`elevata_load`) executes the SQL generated by the Logical Plan + dialect.  

Features:  
- resolves active profile  
- reads target dataset metadata  
- constructs Logical Plan  
- generates SQL via dialect  
- executes SQL or performs a dry‑run  

Example:
```bash
python manage.py elevata_load customers_rawcore --dry-run
```

The Load Runner and SQL Preview use the **same generation pipeline**.

---

# 6. Planned Write-Path Extensions

Although elevata currently focuses on read‑oriented load SQL (SELECT), the architecture is prepared for richer write operations.

## 6.1 MERGE Operations
A future Logical Plan node `LogicalMerge` will support:  
- insert  
- update (slowly changing dimensions)  
- optional delete detection  

## 6.2 Delete Detection
A planned `LogicalDeleteDetect` node would:  
- compare source and target surrogate keys  
- identify deleted records  
- emit dialect‑specific delete SQL

## 6.3 Multi-Statement Loads
Some backends require multi‑statement loads (e.g., temp tables → final insert). Logical Plans are ready to support sequence structures.

---

# 7. Deterministic Generation

The load SQL generator is fully deterministic:  
- stable BK ordering  
- stable hashing patterns  
- stable naming (`__src_rank_ord`)  
- stable Logical Plan tree  

This guarantees reproducible SQL, predictable diffs, and reliable migration workflows.

---

# 8. Summary

Elevata’s load SQL architecture is built on three principles:  

1. **Metadata-driven** – business modeling defines everything  
2. **Dialect-neutral logical plans** – backend independence by design  
3. **AST-based SQL generation** – correctness, portability, and composability  

This ensures that SQL loads are stable, transparent, and backend‑portable, while leaving room for advanced merge/delete features in future versions.
---

© 2025 elevata Labs — Internal Technical Documentation

# âš™ï¸ Load SQL Architecture

This document describes how elevata transforms metadata into executable SQL for load operations.

---

## ğŸ”§ 1. Overview

The load SQL pipeline turns metadata into **complete SQL statements** suitable for execution on various analytical backends.  

Highâ€‘level flow:

```
Metadata â†’ Logical Plan â†’ Expression AST â†’ Dialect Rendering â†’ SQL Load Statement
```

The system is designed so that:  
- Metadata stays backendâ€‘agnostic  
- Logical Plans describe *what* is needed, not *how* it is written  
- Dialects control syntactic differences  
- Execution engines (DuckDB, Postgres, MSSQL, ...) remain fully decoupled

---

## ğŸ”§ 2. Logical Plans for Load Operations

Elevata represents load operations using SQL primitives:  

- `LogicalSelect` â€“ core building block  
- `LogicalUnion` â€“ multi-source resolution  
- `SubquerySource` â€“ ranking, filtering, pre-aggregation  

The Logical Plan is intentionally **dialect-neutral**.

---

## ğŸ”§ 3. Expression AST in Load SQL

During load generation, every column expression is represented as an AST node.  

Supported nodes include:  
- `ColumnRef`  
- `Literal`  
- `ExprRef`  
- `ConcatExpr`  
- `ConcatWsExpr`  
- `CoalesceExpr`  
- `WindowFunctionExpr`  
- `Hash256Expr`  

The AST guarantees that:  
- hashing is consistent across dialects  
- CONCAT/COALESCE behave uniformly  
- window functions are structured, not stringâ€‘built  
- SQL remains predictable and comparable

---

## ğŸ”§ 4. Dialect Rendering

After the Logical Plan is constructed, the load generator asks the selected dialect to turn AST + plan into SQL.

```
sql = dialect.render_select(plan)
```

Each dialect implements:  
- identifier quoting (Postgres â†’ "col", MSSQL â†’ "col", DuckDB â†’ "col")  
- literal rendering (strings, numbers, nulls)  
- hashing functions (SHAâ€‘256 across all dialects)  
- CONCAT / CONCAT_WS  
- COALESCE  
- window functions (ROW_NUMBER)  
- subqueries and unions  

This ensures consistent behavior while using native SQL syntax per backend.

---

## ğŸ”§ 5. Load Runner

The **Load Runner CLI** (`elevata_load`) executes the SQL generated by the Logical Plan + dialect.  

Features:  
- resolves active profile  
- reads target dataset metadata  
- constructs Logical Plan  
- generates SQL via dialect  
- executes SQL or performs a dryâ€‘run  

Example:
```bash
python manage.py elevata_load customers_rawcore --dry-run
```

The Load Runner and SQL Preview use the **same generation pipeline**.

---

## ğŸ”§ 6. Deterministic Generation

The load SQL generator is fully deterministic:  
- stable BK ordering  
- stable hashing patterns  
- stable naming (`__src_rank_ord`)  
- stable Logical Plan tree  

This guarantees reproducible SQL, predictable diffs, and reliable migration workflows.

---

## ğŸ”§ 7. Summary

Elevataâ€™s load SQL architecture is built on three principles:  

1. **Metadata-driven** â€“ business modeling defines everything  
2. **Dialect-neutral logical plans** â€“ backend independence by design  
3. **AST-based SQL generation** â€“ correctness, portability, and composability  

This ensures that SQL loads are stable, transparent, and backendâ€‘portable, while leaving room for extended merge/delete features.

---

Â© 2025 elevata Labs â€” Internal Technical Documentation

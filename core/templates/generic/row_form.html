<!--
elevata - Metadata-driven Data Platform Framework
Copyright © 2025-2026 Ilona Tag

This file is part of elevata.

elevata is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of
the License, or (at your option) any later version.

elevata is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with elevata. If not, see <https://www.gnu.org/licenses/>.

Contact: <https://github.com/elevata-labs/elevata>.
-->

{% load static %}

<!-- Compute the correct hx-post target URL for the form submit.
- If is_new=True  -> post to *_row_create
- If is_new=False -> post to *_row_edit
In scoped mode (parent_pk set) we include parent_pk in the URL. -->

{% if is_new %}
  <!-- creating a new row -->
  {% if parent_pk %}
    {% url model_name|add:'_row_create' parent_pk as form_post_url %}
    {% url model_name|add:'_row_new' parent_pk as refresh_url %}
  {% else %}
    {% url model_name|add:'_row_create' as form_post_url %}
    {% url model_name|add:'_row_new' as refresh_url %}
  {% endif %}
{% else %}
  <!-- editing an existing row -->
  {% if parent_pk %}
    {% url model_name|add:'_row_edit' parent_pk object.pk as form_post_url %}
    {% url model_name|add:'_row_edit' parent_pk object.pk as refresh_url %}
  {% else %}
    {% url model_name|add:'_row_edit' object.pk as form_post_url %}
    {% url model_name|add:'_row_edit' object.pk as refresh_url %}
  {% endif %}
{% endif %}

<!-- Also compute the "Cancel" URL. For editing an existing row,
Cancel should reload the static row view (not the full page).
So we GET the *_row route for that object.
For a brand new row (is_new=True), Cancel just removes the
temporary <tr> in JS. -->

{% if not is_new %}
  {% if parent_pk %}
    {% url model_name|add:'_row' parent_pk object.pk as cancel_url %}
  {% else %}
    {% url model_name|add:'_row' object.pk as cancel_url %}
  {% endif %}
{% endif %}

<tr id="{% if is_new %}row-new{% else %}row-{{ object.pk }}{% endif %}"
    class="{% if is_new %}table-info{% else %}table-warning{% endif %}">

  <td colspan="{{ fields|length|add:'1' }}">

  <div data-elevata-form-wrapper>
    <form method="post"
          class="elevata-form elevata-form-inline"
          data-elevata-refresh-url="{{ refresh_url }}"
          hx-post="{{ form_post_url }}"
          hx-target="{% if is_new %}#row-new{% else %}#row-{{ object.pk }}{% endif %}"
          hx-swap="outerHTML"
          hx-disabled-elt="button[type=submit]"
          data-elevata-refresh-url="{{ refresh_url }}"
    >
      {% csrf_token %}

      <!-- Render the fields in a compact inline layout -->
      {% include "generic/_form_fields.html" %}

      <div class="mt-2 d-flex gap-2">
        <button type="submit" class="btn btn-primary btn-sm">Save</button>

        {% if is_new %}
          <!-- For a new row that hasn't been saved yet:
          we can just drop the temporary row from the DOM. -->
          <button type="button"
                  class="btn btn-secondary btn-sm"
                  onclick="document.getElementById('row-new')?.remove()">
            Cancel
          </button>
        {% else %}
          <!-- For editing an existing row:
          We want to re-fetch the static row HTML via HTMX,
          not navigate away and not reload the page. -->
          <a class="btn btn-secondary btn-sm"
             hx-get="{{ cancel_url }}"
             hx-target="#row-{{ object.pk }}"
             hx-swap="outerHTML">
            Cancel
          </a>
        {% endif %}
      </div>

    </form>
  </div>
  </td>
</tr>

<script>
(function() {
  function bindElevataRefresh(root) {
    const container = root || document;
    const triggers = container.querySelectorAll("[data-elevata-refresh='1']");
    triggers.forEach(el => {
      el.addEventListener("change", () => {
        const formEl = el.closest("form");
        if (!formEl) return;

        // Collect the controlling field value and request refreshed form HTML
        const refreshUrl = formEl.getAttribute("data-elevata-refresh-url");
        if (!refreshUrl) return;

        const params = new URLSearchParams(new FormData(formEl));
        // Use GET refresh (no validation, no saving)
        const url = refreshUrl + "?" + params.toString();

        // HTMX request: replace the form block
        const row = formEl.closest("tr");
        if (!row || !row.id) return;
        htmx.ajax("GET", url, { target: "#" + row.id, swap: "outerHTML" });

      }, { once: false });
    });
  }

  document.addEventListener("DOMContentLoaded", () => bindElevataRefresh(document));
  document.body.addEventListener("htmx:afterSwap", (e) => bindElevataRefresh(e.target));
})();
</script>

{% if model_name == "targetcolumn" %}
<script>
(function() {
  function normNameFromLabel(label) {
    let s = (label || "").trim();
    if (!s) return "";
    // display_key format: "dataset · column"
    if (s.includes("·")) s = s.split("·").pop().trim();
    // safety: "dataset.column"
    if (s.includes(".")) s = s.split(".").pop().trim();
    return s;
  }

  function getSelect() {
    return document.querySelector('[name="upstream_columns"]');
  }

  function setVal(name, value) {
    const el = document.querySelector('[name="' + name + '"]');
    if (!el) return;
    el.value = (value === null || value === undefined) ? "" : value;
    // Trigger change for any dependent UI
    el.dispatchEvent(new Event("change", { bubbles: true }));
  }

  async function onUpstreamChange() {
    const sel = getSelect();
    if (!sel) return;

    // Handle M2M: selectedOptions
    const opts = Array.from(sel.selectedOptions || []);
    if (opts.length === 0) return;

    // MVP: take first selected column
    const upstreamId = opts[0].value;
    if (!upstreamId) return;

    // UX: if target_column_name is empty, auto-fill from upstream label (first selected).
    // This matches common workflow and avoids re-typing.
    const nameEl = document.querySelector('[name="target_column_name"]');
    if (nameEl && !(nameEl.value || "").trim()) {
      const label = (opts[0].textContent || "");
      const cand = normNameFromLabel(label);
      if (cand) {
        nameEl.value = cand;
      }
    }    

    const url = "{% url 'targetcolumn_upstream_meta' %}" + "?upstream_column_id=" + encodeURIComponent(upstreamId);
    const resp = await fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } });
    if (!resp.ok) return;
    const data = await resp.json();

    // Hard overwrite (your preference)
    setVal("datatype", data.datatype || "");
    setVal("max_length", data.max_length);
    setVal("decimal_precision", data.decimal_precision);
    setVal("decimal_scale", data.decimal_scale);

    // nullable is boolean; handle checkbox/select depending on widget
    const nullableEl = document.querySelector('[name="nullable"]');
    if (nullableEl) {
      if (nullableEl.type === "checkbox") {
        nullableEl.checked = !!data.nullable;
      } else {
        nullableEl.value = data.nullable ? "True" : "False";
      }
      nullableEl.dispatchEvent(new Event("change", { bubbles: true }));
    }
  }

  // Bind after HTMX swaps
  function bind() {
    const sel = getSelect();
    if (!sel) return;
    sel.removeEventListener("change", onUpstreamChange);
    sel.addEventListener("change", onUpstreamChange);
  }

  document.addEventListener("DOMContentLoaded", bind);
  document.body.addEventListener("htmx:afterSwap", bind);
})();
</script>
{% endif %}

{% if model_name == "queryunionoutputcolumn" %}
<script>
(function() {
  function norm(s) {
    return (s || "").toString().trim().toLowerCase();
  }

  function q(name) {
    return document.querySelector('[name="' + name + '"]');
  }

  function wrap(el) {
    // Django forms: field is usually in a .mb-2/.form-group wrapper.
    // We search upwards to hide the whole row.
    if (!el) return null;
    return el.closest(".mb-2") || el.closest(".form-group") || el.closest("div");
  }

  function setVisible(fieldName, visible) {
    const el = q(fieldName);
    const w = wrap(el);
    if (!w) return;
    w.style.display = visible ? "" : "none";
  }

  function apply() {
    const dtEl = q("datatype");
    const dt = norm(dtEl ? dtEl.value : "");

    const isDecimal = dt.startsWith("decimal") || dt.startsWith("numeric");
    const isChar =
      dt.startsWith("varchar") || dt.startsWith("char") ||
      dt.startsWith("nvarchar") || dt.startsWith("nchar");

    if (!dt) {
      // No cast datatype => no parameters needed
      setVisible("max_length", false);
      setVisible("decimal_precision", false);
      setVisible("decimal_scale", false);
      return;
    }

    if (isDecimal) {
      setVisible("max_length", false);
      setVisible("decimal_precision", true);
      setVisible("decimal_scale", true);
      return;
    }

    if (isChar) {
      setVisible("max_length", true);
      setVisible("decimal_precision", false);
      setVisible("decimal_scale", false);
      return;
    }

    // Fallback: datatype set but unknown kind → show all optional params
    setVisible("max_length", true);
    setVisible("decimal_precision", true);
    setVisible("decimal_scale", true);
  }

  function bind() {
    const dtEl = q("datatype");
    if (!dtEl) return;
    dtEl.removeEventListener("change", apply);
    dtEl.addEventListener("change", apply);
    apply();
  }

  document.addEventListener("DOMContentLoaded", bind);
  document.body.addEventListener("htmx:afterSwap", bind);
})();
</script>
{% endif %}
